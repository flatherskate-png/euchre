<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Euchre Club Leaderboard + Game Nights</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #f8f9f8;
      margin: 0;
      padding: 2rem;
      color: #222;
    }
    h1, h2, h3 {
      color: #275f49;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      max-width: 700px;
      background: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      margin-top: 1rem;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #e4f2d4;
      color: #275f49;
    }
    .form-box {
      margin-top: 2rem;
      background: #fff;
      padding: 1rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      max-width: 700px;
    }
    input, select {
      padding: 6px;
      margin: 5px 0;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    button {
      background: #275f49;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 8px;
    }
    button:hover {
      background: #1e4a39;
    }
    hr {
      margin: 3rem 0 2rem;
    }
    .hidden { display: none; }
    #cancelledToggle {
      margin-top: 1rem;
      display: inline-block;
      cursor: pointer;
      color: #275f49;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>Euchre Club Leaderboard</h1>

  <!-- Game Night Section -->
  <div class="form-box" id="gameNightBox">
    <h2>Game Night</h2>
    <label>Date:</label>
    <input type="date" id="nightDate"><br>
    <div id="playerCheckList"></div>
    <button onclick="startGameNight()">Start Game Night</button>
    <button id="endNightBtn" class="hidden" onclick="endGameNight()">End Night</button>
    <div id="nightStatusMsg" style="margin-top:0.5rem; color:#275f49;"></div>
  </div>

  <table id="leaderboard">
    <thead>
      <tr><th>Player</th><th>Wins</th><th>Losses</th><th>Points</th></tr>
    </thead>
    <tbody id="leaderboard-body">
      <tr><td colspan="4" style="text-align:center;">Loading...</td></tr>
    </tbody>
  </table>

  <div class="form-box">
    <h3>Add Player</h3>
    <input type="text" id="playerName" placeholder="Enter name" required />
    <button onclick="addPlayer()">Add Player</button>
  </div>

  <hr>

  <h2>Match History</h2>
  <div id="cancelledToggle" onclick="toggleCancelled()">Show Cancelled Matches</div>
  <table id="matches">
    <thead>
      <tr>
        <th>Date</th><th>Team A</th><th>Team B</th><th>Winner</th><th>Points</th><th>Status</th><th>Actions</th>
      </tr>
    </thead>
    <tbody id="matches-body">
      <tr><td colspan="6" style="text-align:center;">Loading...</td></tr>
    </tbody>
  </table>

  <script>
    // ===== CONFIG =====
    const AIRTABLE_TOKEN = 'patRbdM5rKU2gtz83.82c10c403e9f183593e2b2492d93a8bd78600eb4e4bdbe88a7c6318c34486d22';
    const AIRTABLE_BASE  = 'appiiakeJWvHtrd2h';
    const PLAYERS_TABLE  = 'players';
    const MATCHES_TABLE  = 'matches';
    const NIGHTS_TABLE   = 'nights';
    window.playerMap = {};
    let showCancelled = false;
    let currentNight = null;

    // ===== HELPERS =====
    const authHeader = { Authorization: `Bearer ${AIRTABLE_TOKEN}` };
    const extractId = val => Array.isArray(val) ? val[0] : val;

    // ---- TEAM HELPERS ----
function shuffle(arr){
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// Make random teams of 2 from selected player IDs
// Returns { teams: [[p1,p2], ...], bench: null|playerId }
function makeRandomTeams(playerIds){
  const s = shuffle(playerIds);
  const teams = [];
  for (let i = 0; i + 1 < s.length; i += 2) {
    teams.push([s[i], s[i+1]]);
  }
  const bench = (s.length % 2 === 1) ? s[s.length - 1] : null;
  return { teams, bench };
}

// Round robin over team indexes (0..T-1). Supports BYE if odd team count.
function roundRobinTeams(teams){
  const nTeams = teams.length;
  let names = Array.from({length: nTeams}, (_, i) => i);
  let bye = null;
  if (nTeams % 2 === 1) {
    bye = 'BYE';
    names.push(bye);
  }
  const n = names.length;
  const half = n / 2;
  const rounds = [];
  let arr = names.slice();

  for (let r = 0; r < n - 1; r++){
    const matches = [];
    for (let i = 0; i < half; i++){
      const a = arr[i], b = arr[n - 1 - i];
      if (a === bye || b === bye) continue;  // skip BYE
      matches.push([a, b]); // a & b are team indexes
    }
    rounds.push(matches);
    // rotate while keeping first fixed (circle method)
    arr = [arr[0]].concat([arr[n-1]]).concat(arr.slice(1, n-1));
  }
  return rounds; // e.g. [ [ [0,1],[2,3] ], [ [0,2],[1,3] ], ... ]
}


    // ===== LOAD PLAYERS =====
    async function loadPlayers() {
      const res = await fetch(`https://api.airtable.com/v0/${AIRTABLE_BASE}/${PLAYERS_TABLE}`, { headers: authHeader });
      const data = await res.json();
      const tbody = document.getElementById('leaderboard-body');
      tbody.innerHTML = '';
      playerMap = {};
      if (!data.records.length) {
        tbody.innerHTML = '<tr><td colspan="4" style="text-align:center;">No players yet.</td></tr>';
        return;
      }
      data.records.forEach(r => {
        const f = r.fields;
        playerMap[r.id] = f.name;
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${f.name}</td><td>${f.wins||0}</td><td>${f.losses||0}</td><td>${f.points||0}</td>`;
        tbody.appendChild(tr);
      });

      // populate checklist for Game Night
      const list = document.getElementById('playerCheckList');
      list.innerHTML = '<strong>Select players:</strong><br>';
      data.records.forEach(r=>{
        const f=r.fields;
        const id=r.id;
        const label=document.createElement('label');
        label.innerHTML=`<input type="checkbox" class="playerCheck" value="${id}"> ${f.name}<br>`;
        list.appendChild(label);
      });
    }

    // ===== ADD PLAYER =====
    async function addPlayer() {
      const name = document.getElementById('playerName').value.trim();
      if(!name) return;
      await fetch(`https://api.airtable.com/v0/${AIRTABLE_BASE}/${PLAYERS_TABLE}`,{
        method:'POST',headers:{...authHeader,'Content-Type':'application/json'},
        body:JSON.stringify({fields:{name,wins:0,losses:0,points:0}})
      });
      document.getElementById('playerName').value='';
      await loadPlayers();
    }

    // ===== LOAD MATCHES =====
    async function loadMatches() {
      const res = await fetch(`https://api.airtable.com/v0/${AIRTABLE_BASE}/${MATCHES_TABLE}?sort[0][field]=ts&sort[0][direction]=desc`, { headers: authHeader });
      const data = await res.json();
      const tbody = document.getElementById('matches-body');
      tbody.innerHTML='';
      if(!data.records.length){tbody.innerHTML='<tr><td colspan="6" style="text-align:center;">No matches yet.</td></tr>';return;}

      for(const r of data.records){
        const f = r.fields;
        if (!showCancelled && f.status === 'cancelled') continue;
        
        const teamA = [extractId(f.teamA1), extractId(f.teamA2)]
          .map(id => playerMap[id] || '')
          .filter(Boolean).join(', ');
        const teamB = [extractId(f.teamB1), extractId(f.teamB2)]
          .map(id => playerMap[id] || '')
          .filter(Boolean).join(', ');
        const dateStr = f.ts ? new Date(f.ts).toLocaleDateString() : '';
        
        const tr = document.createElement('tr');
        if (f.status === 'cancelled') tr.style.opacity = 0.5;
        
        let actions = '';
        if (f.status === 'pending') {
          actions = `
            <button onclick="recordMatchResult('${r.id}', 'A')">A Wins</button>
            <button onclick="recordMatchResult('${r.id}', 'B')">B Wins</button>
          `;
        }
        
        tr.innerHTML = `
          <td>${dateStr}</td>
          <td>${teamA}</td>
          <td>${teamB}</td>
          <td>${f.winner || ''}</td>
          <td>${f.winPts || 0}</td>
          <td>${f.status || ''}</td>
          <td>${actions}</td>
        `;
        tbody.appendChild(tr);

      }
    }
    function toggleCancelled(){
      showCancelled=!showCancelled;
      document.getElementById('cancelledToggle').innerText=showCancelled?'Hide Cancelled Matches':'Show Cancelled Matches';
      loadMatches();
    }

    // ===== ROUND ROBIN GENERATOR =====
    function generateRoundRobin(players){
      if(players.length%2===1) players.push(null);
      const n=players.length;
      const rounds=[];
      let arr=players.slice();
      for(let r=0;r<n-1;r++){
        const matches=[];
        for(let i=0;i<n/2;i++){
          const a=arr[i],b=arr[n-1-i];
          if(a&&b) matches.push([a,b]);
        }
        rounds.push(matches);
        arr=[arr[0]].concat(arr.slice(-1)).concat(arr.slice(1,-1));
      }
      console.log('DEBUG: Generated rounds',rounds);
      return rounds;
    }

// ===== START GAME NIGHT =====
async function startGameNight() {
  const selected = [...document.querySelectorAll('.playerCheck:checked')].map(c => c.value);
  if (selected.length < 4) {
    alert('Select at least 4 players (minimum 2 teams).');
    return;
  }

  const date = document.getElementById('nightDate').value || new Date().toISOString().slice(0, 10);

  // 1️⃣ Create the game night record
  const nightRes = await fetch(`https://api.airtable.com/v0/${AIRTABLE_BASE}/${NIGHTS_TABLE}`, {
    method: 'POST',
    headers: { ...authHeader, 'Content-Type': 'application/json' },
    body: JSON.stringify({
      fields: {
        date,
        status: 'in progress',
        attendees: selected
      }
    })
  });

  const night = await nightRes.json();
  currentNight = night.id;
  console.log('DEBUG: Created night record', night);

  document.getElementById('nightStatusMsg').innerText = 'Game night started!';
  document.getElementById('endNightBtn').classList.remove('hidden');

  // 2️⃣ Create random teams of two
  const colors = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Purple', 'Pink', 'Black', 'White'];
  function shuffle(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  const shuffled = shuffle(selected);
  const teams = [];
  for (let i = 0; i + 1 < shuffled.length; i += 2) {
    const color = colors[teams.length % colors.length];
    teams.push({ name: `${color} Team`, players: [shuffled[i], shuffled[i + 1]] });
  }
  const bench = shuffled.length % 2 === 1 ? shuffled[shuffled.length - 1] : null;

  console.log('DEBUG: Teams generated', teams);
  if (bench) console.log('DEBUG: Bench player:', playerMap[bench] || bench);

  if (teams.length < 2) {
    alert('Not enough teams to schedule matches.');
    return;
  }

  // 3️⃣ Generate round-robin schedule among teams
  function roundRobinTeams(teamCount) {
    const nTeams = teamCount;
    let names = Array.from({ length: nTeams }, (_, i) => i);
    let bye = null;
    if (nTeams % 2 === 1) {
      bye = 'BYE';
      names.push(bye);
    }
    const n = names.length;
    const half = n / 2;
    const rounds = [];
    let arr = names.slice();
    for (let r = 0; r < n - 1; r++) {
      const matches = [];
      for (let i = 0; i < half; i++) {
        const a = arr[i],
          b = arr[n - 1 - i];
        if (a === bye || b === bye) continue;
        matches.push([a, b]);
      }
      rounds.push(matches);
      arr = [arr[0]].concat([arr[n - 1]]).concat(arr.slice(1, n - 1));
    }
    return rounds;
  }

  const rounds = roundRobinTeams(teams.length);
  console.log('DEBUG: Round-robin schedule', rounds);

  // 4️⃣ Show preview table before posting to Airtable
  const previewDiv = document.createElement('div');
  previewDiv.className = 'form-box';
  previewDiv.innerHTML = `<h3>Team Preview</h3>
    <table>
      <thead><tr><th>Team</th><th>Players</th></tr></thead>
      <tbody>
        ${teams.map(t =>
          `<tr><td>${t.name}</td><td>${t.players.map(p => playerMap[p] || p).join(', ')}</td></tr>`
        ).join('')}
      </tbody>
    </table>
    ${bench ? `<p><em>Bench player: ${playerMap[bench] || bench}</em></p>` : ''}
    <h3>Match Schedule (Preview)</h3>
    <table>
      <thead><tr><th>Round</th><th>Matchups</th></tr></thead>
      <tbody>
        ${rounds.map((matches, i) => `
          <tr><td>Round ${i + 1}</td>
          <td>${matches.map(([a, b]) =>
            `${teams[a].name} vs ${teams[b].name}`
          ).join('<br>')}</td></tr>
        `).join('')}
      </tbody>
    </table>
    <button id="confirmMatchesBtn">✅ Confirm and Create Matches</button>
  `;

  // Insert preview below game night box
  const nightBox = document.getElementById('gameNightBox');
  nightBox.parentNode.insertBefore(previewDiv, nightBox.nextSibling);

  // 5️⃣ Attach event listener for confirmation
  document.getElementById('confirmMatchesBtn').onclick = async () => {
    document.getElementById('confirmMatchesBtn').disabled = true;
    document.getElementById('confirmMatchesBtn').innerText = 'Creating matches...';

    for (const round of rounds) {
      for (const [ti, tj] of round) {
        const teamA = teams[ti];
        const teamB = teams[tj];
        const [a1, a2] = teamA.players;
        const [b1, b2] = teamB.players;

        const matchBody = {
          fields: {
            ts: new Date().toISOString(),
            nights: [String(night.id)],
            teamA1: [a1],
            teamA2: [a2],
            teamB1: [b1],
            teamB2: [b2],
            winner: '',
            winPts: 1,
            status: 'pending'
          }
        };

        console.log(`DEBUG: Posting match: ${teamA.name} vs ${teamB.name}`);
        const matchRes = await fetch(`https://api.airtable.com/v0/${AIRTABLE_BASE}/${MATCHES_TABLE}`, {
          method: 'POST',
          headers: { ...authHeader, 'Content-Type': 'application/json' },
          body: JSON.stringify(matchBody)
        });
        console.log('DEBUG: Match POST result', matchRes.status, await matchRes.text());
      }
    }

    await loadMatches();
    previewDiv.remove();
    alert('Matches created and schedule posted!');
  };
}

    // ===== RECORD MATCH RESULT =====
async function recordMatchResult(matchId, winner) {
  if (!winner) return;
  console.log(`DEBUG: Recording result for ${matchId}, winner = ${winner}`);

  const url = `https://api.airtable.com/v0/${AIRTABLE_BASE}/${MATCHES_TABLE}/${matchId}`;
  const body = {
    fields: {
      winner: winner.toUpperCase(),
      status: 'complete'
    }
  };

  const res = await fetch(url, {
    method: 'PATCH',
    headers: { ...authHeader, 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });

  console.log('DEBUG: Record result response', res.status, await res.text());

  await recalcFromMatches();
  await loadMatches();
}


// ===== END GAME NIGHT =====
async function endGameNight() {
  if (!currentNight) {
    alert("No active game night to end.");
    return;
  }

  const confirmEnd = confirm("Are you sure you want to end this game night?");
  if (!confirmEnd) return;

  console.log("DEBUG: Ending night", currentNight);

  // 1️⃣ Mark the night as complete
  const nightUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE}/${NIGHTS_TABLE}/${currentNight}`;
  const nightBody = { fields: { status: "complete" } };

  const nightRes = await fetch(nightUrl, {
    method: "PATCH",
    headers: { ...authHeader, "Content-Type": "application/json" },
    body: JSON.stringify(nightBody)
  });

  console.log("DEBUG: Updated night status → complete", nightRes.status);

  // 2️⃣ Cancel any remaining pending matches for this night (safe local filter)
  console.log("DEBUG: Looking for pending matches linked to", currentNight);

  const allMatchesRes = await fetch(
    `https://api.airtable.com/v0/${AIRTABLE_BASE}/${MATCHES_TABLE}`,
    { headers: authHeader }
  );
  const allMatchesData = await allMatchesRes.json();

  const pendingMatches = (allMatchesData.records || []).filter(rec => {
    const f = rec.fields || {};
    return f.status === "pending" && Array.isArray(f.nights) && f.nights.includes(currentNight);
  });

  console.log(`DEBUG: Found ${pendingMatches.length} pending matches to cancel`, pendingMatches);

  for (const rec of pendingMatches) {
    const cancelUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE}/${MATCHES_TABLE}/${rec.id}`;
    const cancelBody = { fields: { status: "cancelled" } };

    const cancelRes = await fetch(cancelUrl, {
      method: "PATCH",
      headers: { ...authHeader, "Content-Type": "application/json" },
      body: JSON.stringify(cancelBody)
    });

    console.log("DEBUG: Cancelled match", rec.id, cancelRes.status);
  } // ✅ closes for-loop

  // 3️⃣ Refresh and reset
  await recalcFromMatches();
  await loadMatches();

  document.getElementById("nightStatusMsg").innerText = "Game night ended.";
  document.getElementById("endNightBtn").classList.add("hidden");
  currentNight = null;

  alert("Game night closed. Pending matches marked as cancelled.");
} // ✅ closes endGameNight()


    // ===== RECALC IGNORING CANCELLED =====
    async function recalcFromMatches(){
      const players=await fetch(`https://api.airtable.com/v0/${AIRTABLE_BASE}/${PLAYERS_TABLE}`,{headers:authHeader}).then(r=>r.json());
      const matches=await fetch(`https://api.airtable.com/v0/${AIRTABLE_BASE}/${MATCHES_TABLE}`,{headers:authHeader}).then(r=>r.json());
      const totals={};
      players.records.forEach(p=>{totals[p.id]={wins:0,losses:0,points:0};});
      matches.records.forEach(m=>{
        const f=m.fields||{};
        if(f.status==='cancelled') return;
        const w=(f.winner||'').toUpperCase();
        const a1=extractId(f.teamA1),b1=extractId(f.teamB1);
        if(!a1||!b1) return;
        const winPts=Number(f.winPts||0);
        const winners=w==='A'?[a1]:w==='B'?[b1]:[];
        const losers=w==='A'?[b1]:w==='B'?[a1]:[];
        winners.forEach(id=>{if(totals[id]){totals[id].wins++;totals[id].points+=winPts;}});
        losers.forEach(id=>{if(totals[id])totals[id].losses++;});
      });
      for(const [id,t] of Object.entries(totals)){
        await fetch(`https://api.airtable.com/v0/${AIRTABLE_BASE}/${PLAYERS_TABLE}/${id}`,{
          method:'PATCH',headers:{...authHeader,'Content-Type':'application/json'},
          body:JSON.stringify({fields:t})
        });
      }
      await loadPlayers();
    }

    // ===== INIT =====
    async function init(){
      await loadPlayers();
      await recalcFromMatches();
      await loadMatches();
      // check if a night is active
      const res=await fetch(`https://api.airtable.com/v0/${AIRTABLE_BASE}/${NIGHTS_TABLE}?filterByFormula=${encodeURIComponent("{status}='in progress'")}`,{headers:authHeader});
      const data=await res.json();
      if(data.records.length){
        currentNight=data.records[0].id;
        document.getElementById('endNightBtn').classList.remove('hidden');
        document.getElementById('nightStatusMsg').innerText='Night in progress...';
      }
    }
    init();
  </script>
</body>
</html>
